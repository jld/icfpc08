So it actually tries to avoid stuff now, but doesn't always work.

Issue 1: when about to hit a wall regardless of turning, should brake
  a more nuanced ray evaluator can take care of that
    oh really?  How is a wall defined?
  should still be able to get away with rays vs arcs here
    or maybe not?

Issue 2: steering is a bit screwy
  there is no excuse for some of the diving into craters I've seen

Maybe I should do an actual fake-physics trace (maybe less speed stuff)
  in C, on a quadtree
  will need to feed it guessed max-rot-accel as well as known params
    and also guessed current-rot-speed
  so what?
  trace ahead a ways for each turn state
    ...then periodically branch off, trace back to straight, and cast?
    ...or just trace and that's it?
      not a very good use of CPU
  or the raycasting can be saved
    be given a heading
    steer towards it
      which will make steerage live here, which isn't so bad
        when to stop steering?
          abs(crs) >= crs**2/(2*mra)
      pass back the first desired turn state
    see what gets hit
  what of the martians?
    fake speed = its real velocity `dot` unit from there to Here
               + our real velocity `dot` unit from Here to there
    diminish original actual distance by that * dt; die on 0
      maybe only every N steps if that's an issue
  and what of home?
    ugh.  cheap gradient term, as before?

This still doesn't get real pathfinding; I'm not sure I care.

========

Ignore the next (chronologically previous) section for now.

Stuff I really care about:
  not being a total idiot about martians, now that I know how to make them nasty
    (i.e., veering off the path, but also not diving into a crater)
    do the dot product distance thing?  (with the eventual direction for us)
      but that means no more precomputed gradient.  Okay.
      fakespd = (mvelo . uth) + (CIS DIR . uht)
      util = fakespd / magth
  robustification

========

So it sort of pretends to work now.
ACTION ITEMS:
  The ray evaluator may suck
    but the ray thing seems fundamentally broken anyway?  Sigh.

  [DONE] Allow calling a function (init:stop/0) on eof.
  General packaging
  The supervisor, sooner rather than later.
  Death feedback
    meaningless unless e.g. the martian avoidance actually works; does it?
  avoid spinning forever around the center
    if we're not on beam to go home, then
    2 pi distance to origin / (360 / turn speed)
    if faster than that, then lay off the gas, and optionally brake
    will ideally want to cadge together a test map (how?)
  [DONE, +/-] the ridiculous stochastic raycasting, as described below
  [DONE, +/-] concern about missing small craters (or boulders?)
    can hard-code a fudge factor in the gis
    XXX: should add own radius to boulders (and m) anyway, but not craters
  [DONE] fix the wobbling
    have target rotation state -- neutral within N deg, soft within 2N
    (split the vehicle ctl)
    separate steering module


Raycasting summary:
  have best ray, random span
  generate random ray(s?)
    maybe N and save the best
  test them
    utility: going home (constant mag), not hitting (inverse distance),
             visible martians (inverse distance),
             bonus for straight shot home (inverse?)
    if better, replace and scale down span (with minimum!)
    if worse, scale up span
  on vstate change
    
  THOUGHTS:
    raycast to martians; if crater (nearer than m), then don't worry so?

========

Processes:
  tcp -> binary list, simple msg -> tcp
  binary list -> structured message
  thing what gets the messages and dishes them out?
  world server
    stores obstacles, raycasts them
    accepts geospatial queries
  (eventually, fake martians?)
  Stuff.

Message progress:
  tcp to msgsplit
  iolist to msgfmt
  structured to disher
  on T:
    static objects to world
    (martians to martian emulator?)
  on B/C/K/E: halt stuff
  on I:
    construct static info; kick off stuff

  Then, the decider
    should probably send directly to the tcp port
  Perhaps the decider is informed by the caster or whatever

Gratuitous robustification:
  supervisor to restart stuff
  separate state backup processes

Idea 1:
  pedal to the metal
  cast rays in various directions
    bodge up utility from towards-home-ness and distance of nearest obstacle
    and try to turn "towards" best found
  will probably fail miserably at maps that need actual pathfinding
  and how to integrate martians?
    can calculate frontier of death ignoring obstacles and cast to that
      (ugh)
    vague aversion term
      (mitigate if not LoS?)
  BEES:
    ray casting might miss stuff.  stuff we're about to run into
    how hard is cone/beam casting?
  OKAY.  Break down as:
    process that periodically asks for the best heading and dturns toward it
    process that gets notified of the world state and spams the raycasting
      decrease spread around best on hit, increase on miss
      on update, recast best and use that (and increase?)

Gah, raycasting:
  foo = here - there
  r**2 = (foox + t cos(th)) ** 2 + (fooy + t sin(th)) ** 2
       = foox**2 + 2fooxtcosth + t2 cos2th 
       + fooy**2 + 2fooytsinth + t2 sin2th
       = |foo|**2 + t2 + 2t(foox costh + fooy sinth)

- b +- \sqrt{b^2 - 4ac} / 2a

       a = 1
       b = 2(foox costh + fooy sinth)
       c = |foo|**2 - r**2
