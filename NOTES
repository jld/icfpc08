So it sort of pretends to work now.
ACTION ITEMS:
  The steering is a bit overly daredevilish.
  The ray evaluator kind of sucks.
    Or maybe this span thing is just wrong.
    Maybe roll for span on each cast?

  Allow calling a function (init:stop/0) on eof.
    and general packaging
  The supervisor, sooner rather than later.
  Death feedback.
    meaningless unless the stuff actually works
  avoid spinning forever around the center
    if we're not on beam to go home, then
    2 pi distance to origin / (360 / turn speed)
    if faster than that, then lay off the gas, and optionally brake
    will ideally want to cadge together a test map (how?)
  [DONE, +/-] the ridiculous stochastic raycasting, as described below
  [DONE, +/-] concern about missing small craters (or boulders?)
    can hard-code a fudge factor in the gis
    XXX: should add own radius to boulders (and m) anyway, but not craters
  [DONE] fix the wobbling
    have target rotation state -- neutral within N deg, soft within 2N
    (split the vehicle ctl)
    separate steering module


Raycasting summary:
  have best ray, random span
  generate random ray(s?)
    maybe N and save the best
  test them
    utility: going home (constant mag), not hitting (inverse distance),
             visible martians (inverse distance),
             bonus for straight shot home (inverse?)
    if better, replace and scale down span (with minimum!)
    if worse, scale up span
  on vstate change
    
  THOUGHTS:
    raycast to martians; if crater (nearer than m), then don't worry so?

========

Processes:
  tcp -> binary list, simple msg -> tcp
  binary list -> structured message
  thing what gets the messages and dishes them out?
  world server
    stores obstacles, raycasts them
    accepts geospatial queries
  (eventually, fake martians?)
  Stuff.

Message progress:
  tcp to msgsplit
  iolist to msgfmt
  structured to disher
  on T:
    static objects to world
    (martians to martian emulator?)
  on B/C/K/E: halt stuff
  on I:
    construct static info; kick off stuff

  Then, the decider
    should probably send directly to the tcp port
  Perhaps the decider is informed by the caster or whatever

Gratuitous robustification:
  supervisor to restart stuff
  separate state backup processes

Idea 1:
  pedal to the metal
  cast rays in various directions
    bodge up utility from towards-home-ness and distance of nearest obstacle
    and try to turn "towards" best found
  will probably fail miserably at maps that need actual pathfinding
  and how to integrate martians?
    can calculate frontier of death ignoring obstacles and cast to that
      (ugh)
    vague aversion term
      (mitigate if not LoS?)
  BEES:
    ray casting might miss stuff.  stuff we're about to run into
    how hard is cone/beam casting?
  OKAY.  Break down as:
    process that periodically asks for the best heading and dturns toward it
    process that gets notified of the world state and spams the raycasting
      decrease spread around best on hit, increase on miss
      on update, recast best and use that (and increase?)

Gah, raycasting:
  foo = here - there
  r**2 = (foox + t cos(th)) ** 2 + (fooy + t sin(th)) ** 2
       = foox**2 + 2fooxtcosth + t2 cos2th 
       + fooy**2 + 2fooytsinth + t2 sin2th
       = |foo|**2 + t2 + 2t(foox costh + fooy sinth)

- b +- \sqrt{b^2 - 4ac} / 2a

       a = 1
       b = 2(foox costh + fooy sinth)
       c = |foo|**2 - r**2
